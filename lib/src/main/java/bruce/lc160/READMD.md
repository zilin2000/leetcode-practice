# lc 160

> date: 2024.1.10

## 思路

就是两个链表，如果他们相交： 那么在运行while语句的时候会相遇。如果不，那么他们会同时跑到null。

这段代码是为了找出两个单链表相交的起始节点。它使用了两个指针 `l1` 和 `l2`，分别遍历两个链表 `headA` 和 `headB`。当任一指针到达链表末尾时，会跳转到另一个链表的头部继续遍历。如果两个链表相交，`l1` 和 `l2` 会在相交节点相遇；如果不相交，它们会同时到达链表末尾（都为 `null`），循环结束。

### 时间复杂度

- 设链表 `headA` 的长度为 `a`，链表 `headB` 的长度为 `b`，两链表相交前的长度分别为 `c` 和 `d`（即 `headA` 中从头到相交点的长度为 `c`，`headB` 中从头到相交点的长度为 `d`），相交部分的长度为 `x`。那么 `a = c + x`，`b = d + x`。
- 指针 `l1` 会遍历完链表 `headA` 后进入链表 `headB` 继续遍历，总共遍历的长度为 `a + d`。
- 指针 `l2` 会遍历完链表 `headB` 后进入链表 `headA` 继续遍历，总共遍历的长度为 `b + c`。
- 由于 `a + d = b + c`（都等于 `c + d + x`），所以 `l1` 和 `l2` 会在遍历完相同长度后同时到达相交节点或末尾的 `null`。
- 因此，时间复杂度为 O(a + d) 或 O(b + c)，可以简化为 O(n)，其中 `n` 是两个链表的总长度。

### 空间复杂度

- 代码中只使用了两个额外的指针 `l1` 和 `l2`，并未使用其他额外空间。
- 因此，空间复杂度为 O(1)。

总结：这段代码的时间复杂度是 O(n)，其中 `n` 是两个链表的总长度。空间复杂度是 O(1)。这种方法有效地利用了双指针技巧来找到两个链表的相交节点，且不需要额外空间。